1
00:00:00,000 --> 00:00:04,840

2
00:00:04,840 --> 00:00:07,630
PETE LEPAGE: I'm going to do a
quick intro of our panelists,

3
00:00:07,630 --> 00:00:09,550
and then I will hand it over.

4
00:00:09,550 --> 00:00:10,800
Sitting right here
we have Mairead--

5
00:00:10,800 --> 00:00:13,360

6
00:00:13,360 --> 00:00:14,240
MAIREAD BUCHAN: Buchan.

7
00:00:14,240 --> 00:00:15,050
PETE LEPAGE: Buchan.

8
00:00:15,050 --> 00:00:18,330
So I've messed her name up
probably five times already,

9
00:00:18,330 --> 00:00:21,380
and I've known her for
about four minutes.

10
00:00:21,380 --> 00:00:23,620
So I apologize.

11
00:00:23,620 --> 00:00:25,120
Boris Smus from Google.

12
00:00:25,120 --> 00:00:30,520
We've got Francois Daoust, and
then Matt Caruana, who is

13
00:00:30,520 --> 00:00:32,259
going to come and do
our first intro.

14
00:00:32,259 --> 00:00:46,899

15
00:00:46,899 --> 00:00:49,060
MATT CARUANA GALIZIA: So I'm
going to start by talking

16
00:00:49,060 --> 00:00:51,760
about something really simple.

17
00:00:51,760 --> 00:00:54,430
It's just text input, which is
probably one of the most

18
00:00:54,430 --> 00:01:00,640
fundamental kinds of
input on the web.

19
00:01:00,640 --> 00:01:03,030
I just think that there are a
lot of lessons to be learned

20
00:01:03,030 --> 00:01:07,220
here because obviously, we've
been using this kind of input

21
00:01:07,220 --> 00:01:09,390
for a long time, longer than
we've had touch or

22
00:01:09,390 --> 00:01:10,760
anything like that.

23
00:01:10,760 --> 00:01:15,820
So we've gone quite far toward
standardizing it.

24
00:01:15,820 --> 00:01:18,900
And in the beginning, there
were really only low-level

25
00:01:18,900 --> 00:01:23,690
events like keydown, keypress,
keyup, that are very tied to

26
00:01:23,690 --> 00:01:25,090
the hardware.

27
00:01:25,090 --> 00:01:28,340
In a way, because of that,
they're really good.

28
00:01:28,340 --> 00:01:31,720
They allow us to attach special
functionality to key

29
00:01:31,720 --> 00:01:36,700
combinations in web apps that
should support where users

30
00:01:36,700 --> 00:01:38,590
need to be able to do
things quickly.

31
00:01:38,590 --> 00:01:44,320
The problem is that they're not
really suited to form- and

32
00:01:44,320 --> 00:01:45,690
text-based inputs.

33
00:01:45,690 --> 00:01:49,230
They're too hardware specific.

34
00:01:49,230 --> 00:01:52,870
For a start, they have a lot of
problems, for example, with

35
00:01:52,870 --> 00:01:55,630
non-Latin keyboards.

36
00:01:55,630 --> 00:01:58,570
Like the Chinese keyboard,
pressing the character key for

37
00:01:58,570 --> 00:02:02,990
man, for example, results in
a keydown event with one

38
00:02:02,990 --> 00:02:06,760
character, which is an accented
a and the keyup event

39
00:02:06,760 --> 00:02:08,380
with the actual character
itself.

40
00:02:08,380 --> 00:02:11,230
So it's difficult to
tell what the user

41
00:02:11,230 --> 00:02:14,520
actually wanted to input.

42
00:02:14,520 --> 00:02:17,200
Key events aren't just really
difficult to use.

43
00:02:17,200 --> 00:02:20,660
There are many kinds of text
input that they just aren't

44
00:02:20,660 --> 00:02:22,260
designed to handle.

45
00:02:22,260 --> 00:02:26,670
And really, it's a mistake
to assume that text input

46
00:02:26,670 --> 00:02:29,100
involves a keyboard.

47
00:02:29,100 --> 00:02:32,380
Speech dictation and drag
and drop can also be

48
00:02:32,380 --> 00:02:35,440
used to input text.

49
00:02:35,440 --> 00:02:39,210
The keyboard on Android has a
microphone button on the side,

50
00:02:39,210 --> 00:02:41,650
for example, which you can just
press to dictate text

51
00:02:41,650 --> 00:02:42,900
into an input fields.

52
00:02:42,900 --> 00:02:45,720

53
00:02:45,720 --> 00:02:49,180
Thankfully, no one has attempted
to write a speech

54
00:02:49,180 --> 00:02:52,100
dictation to keypress
event polyfill.

55
00:02:52,100 --> 00:02:54,760
Instead, there's another event
that we can use, which is the

56
00:02:54,760 --> 00:02:57,210
input events.

57
00:02:57,210 --> 00:03:00,230
It's been recently standardized
in HTML5, and

58
00:03:00,230 --> 00:03:02,190
it's now supported by
all major browsers.

59
00:03:02,190 --> 00:03:05,405

60
00:03:05,405 --> 00:03:13,570
So this makes it really easy to
detect input in a hardware

61
00:03:13,570 --> 00:03:15,790
agnostic way.

62
00:03:15,790 --> 00:03:18,870
Key events are just a bit too
low level for most kinds of

63
00:03:18,870 --> 00:03:19,920
text input.

64
00:03:19,920 --> 00:03:22,360
We don't really want to listen
for physical key presses.

65
00:03:22,360 --> 00:03:25,072
Really, we just want
to grab input.

66
00:03:25,072 --> 00:03:29,430
And the input event is a whole
different way of about

67
00:03:29,430 --> 00:03:30,230
thinking about this.

68
00:03:30,230 --> 00:03:33,050
We stop thinking in terms of
hardware and start thinking in

69
00:03:33,050 --> 00:03:34,490
terms of intent.

70
00:03:34,490 --> 00:03:38,470
We just don't really care about
the hardware at all.

71
00:03:38,470 --> 00:03:42,210
That really, I think, makes much
more sense than listening

72
00:03:42,210 --> 00:03:43,460
for key events.

73
00:03:43,460 --> 00:03:45,680

74
00:03:45,680 --> 00:03:49,100
So why didn't we take the
lessons from text input and

75
00:03:49,100 --> 00:03:52,370
apply them to other forms
of input, like

76
00:03:52,370 --> 00:03:55,000
pointing and touching?

77
00:03:55,000 --> 00:03:57,100
So take the anchor
tag, for example.

78
00:03:57,100 --> 00:03:59,390
It can be clicked,
touched, tabbed.

79
00:03:59,390 --> 00:04:03,660

80
00:04:03,660 --> 00:04:06,330
Do we really want to know
if the user clicked

81
00:04:06,330 --> 00:04:07,390
it or touched it?

82
00:04:07,390 --> 00:04:08,895
Most of the time we don't.

83
00:04:08,895 --> 00:04:11,870
We just want to know if
the user wanted to

84
00:04:11,870 --> 00:04:15,180
navigate to that link.

85
00:04:15,180 --> 00:04:18,180
There are fundamental problems
with listening only for click

86
00:04:18,180 --> 00:04:19,360
events on anchor tags.

87
00:04:19,360 --> 00:04:22,170
What if the user tabbed
to the link and then

88
00:04:22,170 --> 00:04:23,530
pressed the Enter key?

89
00:04:23,530 --> 00:04:28,240
Or what if the user issued a
voice command intending to

90
00:04:28,240 --> 00:04:30,190
navigate to that link?

91
00:04:30,190 --> 00:04:34,010
Perhaps we can just have an
activate event that we can

92
00:04:34,010 --> 00:04:37,760
just use to listen for
the intent itself.

93
00:04:37,760 --> 00:04:42,610
This can apply to command
elements, buttons, as well as

94
00:04:42,610 --> 00:04:44,790
anchor tags.

95
00:04:44,790 --> 00:04:48,470
But at the same time,
pointer events are

96
00:04:48,470 --> 00:04:49,640
still really useful.

97
00:04:49,640 --> 00:04:53,680
They're ideal in 2D drawing
applications, and developers

98
00:04:53,680 --> 00:04:56,950
will rely on them to define
custom gestures for their

99
00:04:56,950 --> 00:04:58,690
applications.

100
00:04:58,690 --> 00:05:02,110
So those gestures can come from
a trackpad, a touchscreen

101
00:05:02,110 --> 00:05:04,580
device, a Kinect, or a
Leap Motion device

102
00:05:04,580 --> 00:05:08,060
used in a 2D context.

103
00:05:08,060 --> 00:05:11,650
To ask a common question, can
touch events coexist with

104
00:05:11,650 --> 00:05:12,570
pointer events?

105
00:05:12,570 --> 00:05:12,990
Yes.

106
00:05:12,990 --> 00:05:13,770
Should they?

107
00:05:13,770 --> 00:05:15,190
Perhaps not.

108
00:05:15,190 --> 00:05:17,590
It's unlikely that a developer
would want to capture touch

109
00:05:17,590 --> 00:05:20,680
events as a subset of
pointer events.

110
00:05:20,680 --> 00:05:23,390
If you have access to pointer
events, it's probably best

111
00:05:23,390 --> 00:05:25,260
just to use those.

112
00:05:25,260 --> 00:05:29,390
Besides, the pointer-type
attributes of a pointer event

113
00:05:29,390 --> 00:05:32,640
gives you access to the input
device type, whether it's a

114
00:05:32,640 --> 00:05:35,560
mouse, pen, or touch.

115
00:05:35,560 --> 00:05:38,230
The same point on coexistence
goes for click events.

116
00:05:38,230 --> 00:05:39,960
Sorry, I've gone too far.

117
00:05:39,960 --> 00:05:42,520

118
00:05:42,520 --> 00:05:46,640
In fact, developers will
eventually get to abandon

119
00:05:46,640 --> 00:05:49,690
click events completely, and
they'll be replaced by more

120
00:05:49,690 --> 00:05:53,540
semantically correct and
hardware-agnostic events in

121
00:05:53,540 --> 00:05:55,650
the cases that they're now most
frequently used, like

122
00:05:55,650 --> 00:05:59,370
anchor tags and buttons.

123
00:05:59,370 --> 00:06:03,200
Libraries, like pointer.js for
example, already make it

124
00:06:03,200 --> 00:06:07,290
possible to move away from click
events and move towards

125
00:06:07,290 --> 00:06:08,910
pointers, which are
more abstract.

126
00:06:08,910 --> 00:06:12,620

127
00:06:12,620 --> 00:06:17,220
The trouble is that almost
all forms of inputs we've

128
00:06:17,220 --> 00:06:22,320
discussed so far involve
input in a 2D space.

129
00:06:22,320 --> 00:06:25,280
Take Leap Motion's JavaScript
API for example.

130
00:06:25,280 --> 00:06:28,620

131
00:06:28,620 --> 00:06:33,180
You can receive input as
an array of hands.

132
00:06:33,180 --> 00:06:37,400
And they can be anything from
zero to infinity, really,

133
00:06:37,400 --> 00:06:38,480
because it depends--

134
00:06:38,480 --> 00:06:41,350
if you have multiple Leap Motion
devices, you can just

135
00:06:41,350 --> 00:06:45,240
have an infinite amount
of hands.

136
00:06:45,240 --> 00:06:52,810
And each hand has coordinates
on x, y, and z.

137
00:06:52,810 --> 00:06:55,440
And how do we turn these
into pointers?

138
00:06:55,440 --> 00:06:59,490
Pointers don't really give us
a z-axis, but it shouldn't

139
00:06:59,490 --> 00:07:02,320
really be that difficult to
add it to the standard.

140
00:07:02,320 --> 00:07:07,270

141
00:07:07,270 --> 00:07:11,860
Hands from Leap Motion can fit
into the pointer event spec.

142
00:07:11,860 --> 00:07:17,950

143
00:07:17,950 --> 00:07:20,400
But at the same time--

144
00:07:20,400 --> 00:07:21,640
sorry.

145
00:07:21,640 --> 00:07:22,890
Just a second.

146
00:07:22,890 --> 00:07:34,780

147
00:07:34,780 --> 00:07:39,090
So another big issue is
standardizing gestures.

148
00:07:39,090 --> 00:07:43,050

149
00:07:43,050 --> 00:07:51,960
There isn't really much going on
in this respect with specs.

150
00:07:51,960 --> 00:07:54,660
The closest we've come, really,
toward standardizing

151
00:07:54,660 --> 00:08:05,970
gestures is in the UI event
spec, which gives us a way to

152
00:08:05,970 --> 00:08:11,770
separate the actual method of
input or the physical action

153
00:08:11,770 --> 00:08:14,610
that the user made
from the intent.

154
00:08:14,610 --> 00:08:23,110
So, for example, we can take a
physical push action and turn

155
00:08:23,110 --> 00:08:29,160
it into an activate intent for
a link, which gives us a more

156
00:08:29,160 --> 00:08:30,690
abstract way of dealing
with input.

157
00:08:30,690 --> 00:08:35,330

158
00:08:35,330 --> 00:08:40,590
Taking a swipe gesture, for
example, on a trackpad, in the

159
00:08:40,590 --> 00:08:45,690
UI event spec gives us a way to
turn this into a pan event.

160
00:08:45,690 --> 00:08:52,760
So it doesn't matter whether
the user provided the input

161
00:08:52,760 --> 00:08:57,910
using the speech API, say, as
go left command, as a verbal

162
00:08:57,910 --> 00:09:03,400
command, or by swiping their
hand on a touchscreen or by

163
00:09:03,400 --> 00:09:08,435
just moving your hand in the air
to mimic a swipe action.

164
00:09:08,435 --> 00:09:11,340
The spec gives us a way to
translate this into a pan

165
00:09:11,340 --> 00:09:13,705
event, which we can then use
to move a page around.

166
00:09:13,705 --> 00:09:23,330

167
00:09:23,330 --> 00:09:33,430
Really in conclusion, we want
developers to produce more

168
00:09:33,430 --> 00:09:34,580
adaptive web apps.

169
00:09:34,580 --> 00:09:41,640
To do that, we need to
standardize input methods.

170
00:09:41,640 --> 00:09:44,870
We need browsers to
support pointers.

171
00:09:44,870 --> 00:09:49,870
And it would also help if
we standardize gestures.

172
00:09:49,870 --> 00:09:54,090
But at the same time, a probably
more future-proof way

173
00:09:54,090 --> 00:09:58,730
is by providing developers with
more abstract ways of

174
00:09:58,730 --> 00:10:04,080
dealing with the actions that
the user intends, like

175
00:10:04,080 --> 00:10:07,260
activate actions for links, say,
or panning actions for

176
00:10:07,260 --> 00:10:09,330
moving a page around.

177
00:10:09,330 --> 00:10:15,600
And that will just make our
life a whole lot easier.

178
00:10:15,600 --> 00:10:19,670
Instead of requiring every
developer to listen for all

179
00:10:19,670 --> 00:10:22,850
these different kinds of events,
for all different

180
00:10:22,850 --> 00:10:26,130
kinds of input methods, we can
just listen for one event,

181
00:10:26,130 --> 00:10:30,308
which is the intent,
and support that.

182
00:10:30,308 --> 00:10:31,805
That's it.

183
00:10:31,805 --> 00:10:32,803
Thanks.

184
00:10:32,803 --> 00:10:38,292
[APPLAUSE]

185
00:10:38,292 --> 00:10:40,800
PETE LEPAGE: All right.

186
00:10:40,800 --> 00:10:43,440
So while I'm unlocking my
computer so I can have a look

187
00:10:43,440 --> 00:10:44,820
at the questions,
I know the first

188
00:10:44,820 --> 00:10:46,090
question that's on there.

189
00:10:46,090 --> 00:10:49,540
And it's by far the most popular
question, is what are

190
00:10:49,540 --> 00:10:53,310
the new input types that really,
as developers, we need

191
00:10:53,310 --> 00:10:55,170
to start thinking about today?

192
00:10:55,170 --> 00:10:58,360
And what are the implications
of using those?

193
00:10:58,360 --> 00:11:01,230
So I'd like to hear from all of
you guys what you sort of

194
00:11:01,230 --> 00:11:04,330
think is the biggest and most
important one and what

195
00:11:04,330 --> 00:11:06,800
developers need to think.

196
00:11:06,800 --> 00:11:08,780
So, Mairead, do you
want to go ahead?

197
00:11:08,780 --> 00:11:12,120
MAIREAD BUCHAN: Well, in terms
of the biggest at the moment,

198
00:11:12,120 --> 00:11:14,990
I think in terms of something
that's not just keyboard or

199
00:11:14,990 --> 00:11:16,440
mouse, is touch.

200
00:11:16,440 --> 00:11:18,660
That the majority of your users
are going to have that.

201
00:11:18,660 --> 00:11:20,460
If you're talking about things
that you haven't really

202
00:11:20,460 --> 00:11:25,750
thought of that are coming in,
maybe motion sensing, so maybe

203
00:11:25,750 --> 00:11:27,670
Leap Motion because that's
coming next.

204
00:11:27,670 --> 00:11:31,800
It should be released at the end
of this month allegedly.

205
00:11:31,800 --> 00:11:35,500
But also like [INAUDIBLE] did
loads of work into how many

206
00:11:35,500 --> 00:11:39,740
children are actually using
games consoles, so anything

207
00:11:39,740 --> 00:11:43,290
that you can interact with a
games console with, and also

208
00:11:43,290 --> 00:11:47,370
hybrid mobiles that are games
console devices and mobiles.

209
00:11:47,370 --> 00:11:49,240
So they have joysticks and

210
00:11:49,240 --> 00:11:52,450
touchscreens and maybe keyboards.

211
00:11:52,450 --> 00:11:55,540
So you've got to think about
what application you're making

212
00:11:55,540 --> 00:11:59,120
and what that your users
are likely to be using.

213
00:11:59,120 --> 00:12:00,350
PETE LEPAGE: Cool.

214
00:12:00,350 --> 00:12:01,116
Boris?

215
00:12:01,116 --> 00:12:03,800
BORIS SMUS: Yeah, I would
basically agree with that.

216
00:12:03,800 --> 00:12:07,780
Touch is, realistically
speaking, the only interesting

217
00:12:07,780 --> 00:12:10,650
new mode, at least from the
perspective of what we need to

218
00:12:10,650 --> 00:12:12,030
do as web developers.

219
00:12:12,030 --> 00:12:15,510
But there's a whole slew of
emerging technology that--

220
00:12:15,510 --> 00:12:17,890
I don't think Leap is
at all like the

221
00:12:17,890 --> 00:12:20,030
extent of what's coming.

222
00:12:20,030 --> 00:12:22,330
There's a whole number of--
pretty much every large

223
00:12:22,330 --> 00:12:27,920
corporation has some finger in
this pie of camera-based or

224
00:12:27,920 --> 00:12:31,610
something like this input
technologies, whether it's

225
00:12:31,610 --> 00:12:34,090
tracking fingers,
hands, bodies,

226
00:12:34,090 --> 00:12:36,110
faces, irises, et cetera.

227
00:12:36,110 --> 00:12:38,850
So there's a whole number of
primitives in the real world

228
00:12:38,850 --> 00:12:40,760
that are going to start
to be tracked.

229
00:12:40,760 --> 00:12:43,430
And this is obviously a little
further out, but still

230
00:12:43,430 --> 00:12:44,732
interesting.

231
00:12:44,732 --> 00:12:49,210
FRANCOIS DAOUST: So just to
maybe add something more on

232
00:12:49,210 --> 00:12:52,700
top of the huge list you
already mentioned.

233
00:12:52,700 --> 00:12:56,700
Maybe at the intent level that
Pete mentioned, I would

234
00:12:56,700 --> 00:13:01,340
perhaps add presence or user
attention as a possible way

235
00:13:01,340 --> 00:13:03,910
for a more immersive
experience.

236
00:13:03,910 --> 00:13:06,090
For instance, if you have a
screen that is displayed on a

237
00:13:06,090 --> 00:13:09,890
wall, a mirror, or something,
something that is connected,

238
00:13:09,890 --> 00:13:13,920
you might just want to know
whether the user is in front

239
00:13:13,920 --> 00:13:15,450
of it or whether it's not.

240
00:13:15,450 --> 00:13:17,860
And the thing that you're
going to display, the

241
00:13:17,860 --> 00:13:20,890
interaction with the user, will
change based on that.

242
00:13:20,890 --> 00:13:23,790
Again, it's at the intent level,
so you don't need to

243
00:13:23,790 --> 00:13:29,520
know how the system knows
that the user is there.

244
00:13:29,520 --> 00:13:32,560
They already have some
mechanisms to do that with the

245
00:13:32,560 --> 00:13:36,800
RFID, with NFC, with, actually,
the user manually

246
00:13:36,800 --> 00:13:40,170
entering his status on Skype
or whatever saying, I'm

247
00:13:40,170 --> 00:13:42,860
available, I'm busy,
I'm not there.

248
00:13:42,860 --> 00:13:44,330
So it has [? fallback, ?]

249
00:13:44,330 --> 00:13:49,980
and that could be a new kind of
a user input coming in the

250
00:13:49,980 --> 00:13:52,436
near future.

251
00:13:52,436 --> 00:13:55,050
MATT CARUANA GALIZIA: I think
that one of the most

252
00:13:55,050 --> 00:13:59,200
interesting developments in
input is speech, because it

253
00:13:59,200 --> 00:14:01,830
forces us to think of input
in a whole new way.

254
00:14:01,830 --> 00:14:06,550
We suddenly have to deal with a
method of input that doesn't

255
00:14:06,550 --> 00:14:09,120
involve fingers, doesn't
involve hands, doesn't

256
00:14:09,120 --> 00:14:12,260
touching, moving, or
anything like that.

257
00:14:12,260 --> 00:14:16,480
So we just have to completely
change the way that we think

258
00:14:16,480 --> 00:14:19,670
about input and write
applications

259
00:14:19,670 --> 00:14:22,510
in different ways.

260
00:14:22,510 --> 00:14:26,640
The first step is to probably
change standards or develop

261
00:14:26,640 --> 00:14:31,000
new standards to allow
developers to more easily

262
00:14:31,000 --> 00:14:33,380
support this new form of inputs

263
00:14:33,380 --> 00:14:34,980
without relying on polyfills.

264
00:14:34,980 --> 00:14:38,270

265
00:14:38,270 --> 00:14:43,520
I tend to think that providing
polyfills is probably a good

266
00:14:43,520 --> 00:14:45,380
way of getting started.

267
00:14:45,380 --> 00:14:49,110
We can produce the polyfill, get
developers to start using

268
00:14:49,110 --> 00:14:53,866
it, and then eventually the
standard will come later.

269
00:14:53,866 --> 00:14:57,330
PETE LEPAGE: Actually, that's
a great sort of segue to the

270
00:14:57,330 --> 00:15:00,420
next question that Andrew
had put in.

271
00:15:00,420 --> 00:15:02,960
And his question was, if
we use a mechanism for

272
00:15:02,960 --> 00:15:06,650
abstracting all directional
input into pointer events,

273
00:15:06,650 --> 00:15:10,050
will we ultimately regret
that decision?

274
00:15:10,050 --> 00:15:12,570
I believe there's a pointer
event polyfill library you can

275
00:15:12,570 --> 00:15:14,270
start playing with today.

276
00:15:14,270 --> 00:15:17,650
But are we regret that decision
in 6 months, 12

277
00:15:17,650 --> 00:15:21,301
months, maybe in 60 months?

278
00:15:21,301 --> 00:15:23,850
BORIS SMUS: I'll take
a stab at this.

279
00:15:23,850 --> 00:15:27,490
So I think that there's some
kinds of directional input

280
00:15:27,490 --> 00:15:30,690
that makes sense to try to
abstract as a pointer and

281
00:15:30,690 --> 00:15:34,010
other things it totally
does not.

282
00:15:34,010 --> 00:15:37,560
Things that are screen based is
an obvious fit, where you

283
00:15:37,560 --> 00:15:39,860
have a natural mapping to
screen coordinates.

284
00:15:39,860 --> 00:15:41,020
This includes mouse and touch.

285
00:15:41,020 --> 00:15:44,480
But when you're talking about
things like Leap or any sort

286
00:15:44,480 --> 00:15:47,310
of sensing in the real world, I
think you quickly fall into

287
00:15:47,310 --> 00:15:50,580
this weird place where
it's unclear what the

288
00:15:50,580 --> 00:15:52,630
client x is, really.

289
00:15:52,630 --> 00:15:56,290
And at that point, you're
dealing with physical units if

290
00:15:56,290 --> 00:15:59,720
you have some z-coordinates,
and you're just

291
00:15:59,720 --> 00:16:01,320
polluting the space.

292
00:16:01,320 --> 00:16:03,090
I feel like it's a
perilous path.

293
00:16:03,090 --> 00:16:06,826
So I guess the short
answer, depends.

294
00:16:06,826 --> 00:16:07,910
PETE LEPAGE: All right.

295
00:16:07,910 --> 00:16:08,395
Anybody--

296
00:16:08,395 --> 00:16:11,090
MAIREAD BUCHAN: Your only other
choice is coding every

297
00:16:11,090 --> 00:16:13,040
single aspect from scratch.

298
00:16:13,040 --> 00:16:16,370
And is your project going
to be profitable?

299
00:16:16,370 --> 00:16:18,630
Have you really got the
development time to do

300
00:16:18,630 --> 00:16:23,650
pointers and touch and click and
keyboard, which I reckon

301
00:16:23,650 --> 00:16:26,510
probably most web developers
are failing at already.

302
00:16:26,510 --> 00:16:29,400
Like we're not even doing
keyboard and click that well.

303
00:16:29,400 --> 00:16:31,880
So are you going to add another
interaction paradigm

304
00:16:31,880 --> 00:16:34,190
into your development
lifecycle?

305
00:16:34,190 --> 00:16:36,370
PETE LEPAGE: But isn't the point
of pointer events that

306
00:16:36,370 --> 00:16:39,690
you can sort of reduce the touch
and the mouse and all

307
00:16:39,690 --> 00:16:41,730
that kind of stuff to
one simple place?

308
00:16:41,730 --> 00:16:42,100
MAIREAD BUCHAN: Yeah.

309
00:16:42,100 --> 00:16:43,020
Absolutely.

310
00:16:43,020 --> 00:16:45,780
I think it's a great idea,
and I agree with Matt.

311
00:16:45,780 --> 00:16:47,400
You've got to abstract it.

312
00:16:47,400 --> 00:16:49,980
Otherwise, we're entering
a world of pain.

313
00:16:49,980 --> 00:16:50,646
You've got to.

314
00:16:50,646 --> 00:16:51,480
BORIS SMUS: Yeah.

315
00:16:51,480 --> 00:16:53,610
I think abstracting is
important, but you still need

316
00:16:53,610 --> 00:16:55,840
to retain the ability of
distinguishing between these

317
00:16:55,840 --> 00:16:58,860
different types of input.

318
00:16:58,860 --> 00:17:02,410
Like for example, you often do
want to have a touch-specific

319
00:17:02,410 --> 00:17:05,069
thing, which pointer events do
let you do because you can

320
00:17:05,069 --> 00:17:07,140
distinguish between [INAUDIBLE]
and touch.

321
00:17:07,140 --> 00:17:12,619
But that's an important thing
to carry over so that we're

322
00:17:12,619 --> 00:17:14,920
still able to do these sorts
of customizations.

323
00:17:14,920 --> 00:17:15,680
FRANCOIS DAOUST: Yeah.

324
00:17:15,680 --> 00:17:20,250
So just to complete, again,
there are different layers or

325
00:17:20,250 --> 00:17:21,369
different levels.

326
00:17:21,369 --> 00:17:24,329
And you want both of them--

327
00:17:24,329 --> 00:17:28,329
maybe there's more than two,
but you want actually the

328
00:17:28,329 --> 00:17:32,740
intent level for generic
interaction, and you want the

329
00:17:32,740 --> 00:17:35,680
more precise level, the pointer
level, being one, the

330
00:17:35,680 --> 00:17:40,430
touch level being a
deeper one, maybe.

331
00:17:40,430 --> 00:17:42,820
All of them have some use cases

332
00:17:42,820 --> 00:17:45,150
that need to be fulfilled.

333
00:17:45,150 --> 00:17:50,800
So the difficulty is teaching
the developer what to use and

334
00:17:50,800 --> 00:17:53,270
how not to misuse, because if
you mix the levels, you're

335
00:17:53,270 --> 00:17:57,090
going to end up breaking your
app pretty quickly, I suppose.

336
00:17:57,090 --> 00:17:57,660
PETE LEPAGE: Yeah.

337
00:17:57,660 --> 00:18:00,070
And I think we've all seen lots
of apps that have gotten

338
00:18:00,070 --> 00:18:03,320
a little bit broken with touch
and that kind of thing.

339
00:18:03,320 --> 00:18:03,890
Well, let's go--

340
00:18:03,890 --> 00:18:04,160
all right.

341
00:18:04,160 --> 00:18:05,460
Go ahead.

342
00:18:05,460 --> 00:18:07,730
BORIS SMUS: A question for
people in the audience.

343
00:18:07,730 --> 00:18:10,880
How many of you actually know
what pointer events are?

344
00:18:10,880 --> 00:18:11,415
Just curious.

345
00:18:11,415 --> 00:18:12,592
PETE LEPAGE: Awesome.

346
00:18:12,592 --> 00:18:13,620
BORIS SMUS: OK.

347
00:18:13,620 --> 00:18:16,780
So we actually are talking about
something that half the

348
00:18:16,780 --> 00:18:19,410
people don't seem to
know what it is.

349
00:18:19,410 --> 00:18:19,590
OK.

350
00:18:19,590 --> 00:18:19,800
Cool.

351
00:18:19,800 --> 00:18:22,590
So maybe just a quick intro
to pointer events.

352
00:18:22,590 --> 00:18:22,760
Basically--

353
00:18:22,760 --> 00:18:24,716
PETE LEPAGE: 30 seconds.

354
00:18:24,716 --> 00:18:27,300
BORIS SMUS: Pointer events is a
way to consolidate mouse and

355
00:18:27,300 --> 00:18:31,490
touch input into one type
of event system.

356
00:18:31,490 --> 00:18:35,610
The reason for this is touch
events and mouse events are

357
00:18:35,610 --> 00:18:38,260
basically two completely
separate systems.

358
00:18:38,260 --> 00:18:41,630
There's this weird synthetic
event concept where mouse

359
00:18:41,630 --> 00:18:44,390
events are generated for touch
on mobile devices.

360
00:18:44,390 --> 00:18:46,880
So if you don't have a
touch handler, you

361
00:18:46,880 --> 00:18:47,520
still get mouse events.

362
00:18:47,520 --> 00:18:50,400
But this leads to a whole
bunch of problems.

363
00:18:50,400 --> 00:18:52,450
So, anyway, now that we're
on the same page,

364
00:18:52,450 --> 00:18:53,580
another quick question.

365
00:18:53,580 --> 00:18:56,030
How many of you actually have
touch-specific handlers in

366
00:18:56,030 --> 00:18:57,280
your applications?

367
00:18:57,280 --> 00:19:00,560

368
00:19:00,560 --> 00:19:00,640
OK.

369
00:19:00,640 --> 00:19:02,160
So maybe about half.

370
00:19:02,160 --> 00:19:02,630
Sounds good.

371
00:19:02,630 --> 00:19:02,960
Thanks.

372
00:19:02,960 --> 00:19:04,610
PETE LEPAGE: Cool.

373
00:19:04,610 --> 00:19:07,580
Mairead, I wanted to go
to your question next.

374
00:19:07,580 --> 00:19:10,500
Do you think that devices lying
about the event they are

375
00:19:10,500 --> 00:19:14,090
sending, ie, touch devices
sending fake clicks, motion

376
00:19:14,090 --> 00:19:18,220
sensors that likely motion
faking a touch event, is

377
00:19:18,220 --> 00:19:22,690
unhelpful and somewhat
reminiscent of browsers lying

378
00:19:22,690 --> 00:19:24,636
about their user agent?

379
00:19:24,636 --> 00:19:27,620
MAIREAD BUCHAN: So to kind of
clarify this, well, I was

380
00:19:27,620 --> 00:19:28,650
looking at the Leap Motion.

381
00:19:28,650 --> 00:19:31,760
And what it does is
it projects a 2D

382
00:19:31,760 --> 00:19:33,140
plane in front of you.

383
00:19:33,140 --> 00:19:36,030
And when you touch that
plane, it sends

384
00:19:36,030 --> 00:19:37,530
that as a touch event.

385
00:19:37,530 --> 00:19:40,960
So anything you've built to be
touch related, Leap Motion can

386
00:19:40,960 --> 00:19:45,930
do in 3D by pretending
it has a 2D surface.

387
00:19:45,930 --> 00:19:48,760
If you look at how a touchscreen
pretends that it's

388
00:19:48,760 --> 00:19:51,930
had a click, and that doesn't
really work, is the Leap

389
00:19:51,930 --> 00:19:55,110
Motion touch really going
to be the same as

390
00:19:55,110 --> 00:19:56,270
you touching a surface?

391
00:19:56,270 --> 00:19:58,900
It's not, is it?

392
00:19:58,900 --> 00:20:01,810
So the more we end up
down this dark path.

393
00:20:01,810 --> 00:20:04,760
And also, if you're doing
feature detection, are you a

394
00:20:04,760 --> 00:20:05,410
touch device?

395
00:20:05,410 --> 00:20:06,060
Yes, I am.

396
00:20:06,060 --> 00:20:07,040
No, it's not.

397
00:20:07,040 --> 00:20:09,660
It's something else lying that
it's a touch device.

398
00:20:09,660 --> 00:20:13,530
So that's dangerous ground, I
think, because, what, are you

399
00:20:13,530 --> 00:20:16,350
going to go back to user agent
sniffing because your feature

400
00:20:16,350 --> 00:20:18,360
detection is not working?

401
00:20:18,360 --> 00:20:21,958
I don't know what's the
answer to that.

402
00:20:21,958 --> 00:20:23,920
MATT CARUANA GALIZIA: One of
the problems that we have

403
00:20:23,920 --> 00:20:27,930
right now, in fact, is devices
that support multiple input

404
00:20:27,930 --> 00:20:31,610
types, like laptops with screens
which you can touch,

405
00:20:31,610 --> 00:20:34,085
for example, but which also
have a mouse connected.

406
00:20:34,085 --> 00:20:38,360

407
00:20:38,360 --> 00:20:42,950
In the FD web app, we use a
library called FT Scroller.

408
00:20:42,950 --> 00:20:48,150
But the issue that we have with
scrolling right now is

409
00:20:48,150 --> 00:20:52,700
that we feature detect first
if the browser supports

410
00:20:52,700 --> 00:20:55,870
pointers, then if it supports
touches, and then obviously

411
00:20:55,870 --> 00:20:58,750
will fall back to
mouse events.

412
00:20:58,750 --> 00:21:05,506
The problem with that is that
we sacrifice usability.

413
00:21:05,506 --> 00:21:08,560

414
00:21:08,560 --> 00:21:12,070
After we successfully feature
detect touch events, it means

415
00:21:12,070 --> 00:21:16,100
that user won't be able to use
the mouse, for example, to

416
00:21:16,100 --> 00:21:17,350
scroll a layer.

417
00:21:17,350 --> 00:21:19,610

418
00:21:19,610 --> 00:21:23,140
We should really be able to just
use pointer events, and

419
00:21:23,140 --> 00:21:26,100
it should work for all the
different inputs, for the

420
00:21:26,100 --> 00:21:29,474
mouse or for the touchscreen
itself.

421
00:21:29,474 --> 00:21:30,400
BORIS SMUS: Yeah.

422
00:21:30,400 --> 00:21:35,370
So on that point, I think for
the case of a touch laptop,

423
00:21:35,370 --> 00:21:40,050
it's important not to
just ignore mouse.

424
00:21:40,050 --> 00:21:43,180
Maybe the best practice is to
prevent default on such events

425
00:21:43,180 --> 00:21:47,340
as opposed to not listening to
mouse events at all, since you

426
00:21:47,340 --> 00:21:50,655
can no longer assume that
touch implies not mouse.

427
00:21:50,655 --> 00:21:55,250

428
00:21:55,250 --> 00:21:59,430
And on the question of reducing
different kinds of

429
00:21:59,430 --> 00:22:03,940
input to different other kinds
of input, I agree with you.

430
00:22:03,940 --> 00:22:05,310
It's a dangerous path.

431
00:22:05,310 --> 00:22:10,240
Just like reducing touch to
mouse didn't work, reducing a

432
00:22:10,240 --> 00:22:12,760
Leap, which actually tracks--

433
00:22:12,760 --> 00:22:14,900
it's a sausage tracker,
essentially, tracks sausages

434
00:22:14,900 --> 00:22:16,090
in the air--

435
00:22:16,090 --> 00:22:20,830
reducing that into a touchscreen
also doesn't work.

436
00:22:20,830 --> 00:22:25,310
And it's an insult to what
Leap can do, just like

437
00:22:25,310 --> 00:22:28,800
reducing a touchscreen to a
mouse basically eliminates any

438
00:22:28,800 --> 00:22:31,380
possibility of multitouch.

439
00:22:31,380 --> 00:22:36,470
We have completely unexplored
territory in the 3D tracking

440
00:22:36,470 --> 00:22:41,102
space that we would just
lose entirely.

441
00:22:41,102 --> 00:22:44,420
PETE LEPAGE: I want to dive a
little bit deeper into the

442
00:22:44,420 --> 00:22:48,810
interactions when using both
touch and mouse because,

443
00:22:48,810 --> 00:22:53,670
Boris, you showed me a couple
of demos yesterday where

444
00:22:53,670 --> 00:22:56,110
having an object on screen, you
can put your finger on it,

445
00:22:56,110 --> 00:22:59,370
and then use the touchpad or
your mouse to make it move.

446
00:22:59,370 --> 00:23:01,680
I think there are a lot
of really interesting

447
00:23:01,680 --> 00:23:03,530
opportunities there that
haven't been explored.

448
00:23:03,530 --> 00:23:05,960
Let's talk about some of
those different ones

449
00:23:05,960 --> 00:23:07,210
for a minute or so.

450
00:23:07,210 --> 00:23:09,770

451
00:23:09,770 --> 00:23:10,570
BORIS SMUS: OK.

452
00:23:10,570 --> 00:23:14,180
So I guess there's a
couple things that

453
00:23:14,180 --> 00:23:15,900
are interesting here.

454
00:23:15,900 --> 00:23:18,910
So the first one is just the
transition between the two

455
00:23:18,910 --> 00:23:24,200
modes, in like a Windows 8
touch laptop, seems like

456
00:23:24,200 --> 00:23:26,930
there's some opportunity
to have some--

457
00:23:26,930 --> 00:23:30,590
almost like a responsive
input-type approach, where

458
00:23:30,590 --> 00:23:32,300
instead of adapting to
screen size, you're

459
00:23:32,300 --> 00:23:35,730
adapting to input method.

460
00:23:35,730 --> 00:23:37,340
Just kind of throwing
this idea out there.

461
00:23:37,340 --> 00:23:41,110
I haven't seen anyone do it
well, but it's interesting.

462
00:23:41,110 --> 00:23:44,770
The other angle is multiple
inputs simultaneously.

463
00:23:44,770 --> 00:23:49,570
So like what Pete was
describing, with a trackpad

464
00:23:49,570 --> 00:23:52,790
and a simultaneous touchscreen
interaction.

465
00:23:52,790 --> 00:23:56,620
Again, I've built some
prototypes around this stuff,

466
00:23:56,620 --> 00:23:58,910
but it's pretty early.

467
00:23:58,910 --> 00:24:02,210
And I think it'd be cool to see
more of them from other

468
00:24:02,210 --> 00:24:06,200
people and have a discussion
about them, but it's a little

469
00:24:06,200 --> 00:24:07,930
too early, I think,
to really go into.

470
00:24:07,930 --> 00:24:08,820
PETE LEPAGE: All right.

471
00:24:08,820 --> 00:24:10,270
Fair answer.

472
00:24:10,270 --> 00:24:15,100
Anybody else have any
thoughts on that?

473
00:24:15,100 --> 00:24:18,030
All right.

474
00:24:18,030 --> 00:24:21,310
So the next question we have,
tapping links on a page incurs

475
00:24:21,310 --> 00:24:25,890
a 300 millisecond delay to work
out if the user is doing

476
00:24:25,890 --> 00:24:28,360
a double tap to zoom.

477
00:24:28,360 --> 00:24:30,090
Can we get rid of this
delay somehow

478
00:24:30,090 --> 00:24:31,440
without losing the zoom?

479
00:24:31,440 --> 00:24:36,520

480
00:24:36,520 --> 00:24:38,750
MATT CARUANA GALIZIA: In
maintaining FastClick, which

481
00:24:38,750 --> 00:24:45,170
is a polyfill that we developed
at the FT to get rid

482
00:24:45,170 --> 00:24:49,380
of the delay, we've dealt
with a lot of issues.

483
00:24:49,380 --> 00:24:50,010
[? You will ?]

484
00:24:50,010 --> 00:24:53,010
constantly bring up the issue
that we've effectively

485
00:24:53,010 --> 00:24:58,740
disabled zooming by firing a
click event as soon as the

486
00:24:58,740 --> 00:25:01,645
finger leaves the screen,
as soon as the touch

487
00:25:01,645 --> 00:25:02,895
end event is fired.

488
00:25:02,895 --> 00:25:06,190

489
00:25:06,190 --> 00:25:10,250
The issue seems to be that
really, we can't have the best

490
00:25:10,250 --> 00:25:15,370
of both worlds at the moment
without an API that we can use

491
00:25:15,370 --> 00:25:19,880
to zoom the page when we
detect a second tap.

492
00:25:19,880 --> 00:25:23,550
But even in that case, really,
because once the finger has

493
00:25:23,550 --> 00:25:27,890
left the screen, then you've
already fired the click event.

494
00:25:27,890 --> 00:25:32,740
So we haven't figured out a
way yet to get the both of

495
00:25:32,740 --> 00:25:34,580
both worlds.

496
00:25:34,580 --> 00:25:38,080
FRANCOIS DAOUST: I guess,
unfortunately, the double tap

497
00:25:38,080 --> 00:25:41,320
thing is really at the operating
system level.

498
00:25:41,320 --> 00:25:44,480
It's something that
the device brings.

499
00:25:44,480 --> 00:25:52,300
And you cannot just prevent it
from happening within a web

500
00:25:52,300 --> 00:25:57,770
app, within a web browser,
within this device, without--

501
00:25:57,770 --> 00:26:01,960
we can't even imagine, I guess,
an API that would allow

502
00:26:01,960 --> 00:26:06,150
the web app to prevent the
double tap, because it's a

503
00:26:06,150 --> 00:26:07,220
usability feature.

504
00:26:07,220 --> 00:26:11,105
It has also accessibility
implications.

505
00:26:11,105 --> 00:26:14,550

506
00:26:14,550 --> 00:26:18,210
I guess the answer for me is,
no, you cannot right now.

507
00:26:18,210 --> 00:26:22,010
New devices will probably
improve the touch interaction

508
00:26:22,010 --> 00:26:24,926
and maybe remove
the double tap.

509
00:26:24,926 --> 00:26:25,710
I don't know.

510
00:26:25,710 --> 00:26:28,540
MATT CARUANA GALIZIA: Do you
that if we're building

511
00:26:28,540 --> 00:26:32,250
responsive layouts, then the
users shouldn't really have to

512
00:26:32,250 --> 00:26:33,395
zoom in the first place?

513
00:26:33,395 --> 00:26:36,656
FRANCOIS DAOUST: Well, no,
but I know that the--

514
00:26:36,656 --> 00:26:41,070
I believe that they should be
able to zoom in, but I know

515
00:26:41,070 --> 00:26:45,850
that it can trigger a lot
analyst discussions on who's

516
00:26:45,850 --> 00:26:47,570
right and who's wrong.

517
00:26:47,570 --> 00:26:49,080
So I'm more--

518
00:26:49,080 --> 00:26:50,870
it's the same thing with
the meta viewport

519
00:26:50,870 --> 00:26:53,930
when you disable scaling.

520
00:26:53,930 --> 00:26:56,360
It's the same discussion
somehow.

521
00:26:56,360 --> 00:27:00,550
And in my view, it's supposed
to be the user choosing

522
00:27:00,550 --> 00:27:02,080
whether he wants to
zoom in o or.

523
00:27:02,080 --> 00:27:04,060
He may have good reasons
to do that.

524
00:27:04,060 --> 00:27:10,300
But on mobile devices or tablet
devices, it's hard to

525
00:27:10,300 --> 00:27:15,720
find another interaction that
could be used to zoom in.

526
00:27:15,720 --> 00:27:18,030
So you're kind of stuck.

527
00:27:18,030 --> 00:27:21,630
So when you develop web apps for
customers, for instance,

528
00:27:21,630 --> 00:27:25,320
you will have to make
some workarounds.

529
00:27:25,320 --> 00:27:28,980
And you will disable zoom in,
even if you don't want to,

530
00:27:28,980 --> 00:27:30,810
just because otherwise,
the web app is

531
00:27:30,810 --> 00:27:32,726
not responsive enough.

532
00:27:32,726 --> 00:27:35,580
BORIS SMUS: So we've had lots
of discussions about this

533
00:27:35,580 --> 00:27:36,720
particular thing.

534
00:27:36,720 --> 00:27:40,150
And I think this is an
optimization that's either in

535
00:27:40,150 --> 00:27:43,060
the Chrome beta for Android
or coming soon.

536
00:27:43,060 --> 00:27:46,680
Basically, if you have a
non-user-scalable page,

537
00:27:46,680 --> 00:27:50,670
there's no reason to have this
click delay, so we just

538
00:27:50,670 --> 00:27:53,560
disable it.

539
00:27:53,560 --> 00:27:56,960
Basically, I think this is the
way that things should be, and

540
00:27:56,960 --> 00:28:01,200
FastClick is a giant hack that
should never have existed.

541
00:28:01,200 --> 00:28:03,400
I'm not saying it's
like a bad thing.

542
00:28:03,400 --> 00:28:04,390
Clearly, there was a--

543
00:28:04,390 --> 00:28:05,250
MATT CARUANA GALIZIA:
I agree completely.

544
00:28:05,250 --> 00:28:06,980
BORIS SMUS: There was a
need for it when there

545
00:28:06,980 --> 00:28:07,610
was a need for it.

546
00:28:07,610 --> 00:28:10,450
But it's time to get past that
and fix our browsers.

547
00:28:10,450 --> 00:28:11,700
MATT CARUANA GALIZIA: I agree.

548
00:28:11,700 --> 00:28:14,855

549
00:28:14,855 --> 00:28:17,410
MAIREAD BUCHAN: I don't know.

550
00:28:17,410 --> 00:28:18,790
Why would you loading a page?

551
00:28:18,790 --> 00:28:23,340
Or can you guarantee that when
a pages is loaded that it's

552
00:28:23,340 --> 00:28:25,320
going to be zoom disabled?

553
00:28:25,320 --> 00:28:25,920
Do you see what I mean?

554
00:28:25,920 --> 00:28:28,880
Like even if you've made a
responsive mobile site, a user

555
00:28:28,880 --> 00:28:32,950
still might want to zoom
in on something.

556
00:28:32,950 --> 00:28:37,230
Can you ever really make
a web page that's--

557
00:28:37,230 --> 00:28:40,500
BORIS SMUS: I would argue that
yes, because if you look at

558
00:28:40,500 --> 00:28:42,430
native apps, basically--

559
00:28:42,430 --> 00:28:45,570
if we look at the extreme of
adapting content to your

560
00:28:45,570 --> 00:28:51,540
device, then in the ideal case,
we should be doing this.

561
00:28:51,540 --> 00:28:52,240
I don't think it's

562
00:28:52,240 --> 00:28:54,760
unreasonable for special cases.

563
00:28:54,760 --> 00:28:57,980
I'm not saying disable pinch
zooming in general or double

564
00:28:57,980 --> 00:29:00,280
tap to zoom, but I
think there are

565
00:29:00,280 --> 00:29:01,980
cases where it's justified.

566
00:29:01,980 --> 00:29:04,650
MATT CARUANA GALIZIA: If we
have a pinch event, then

567
00:29:04,650 --> 00:29:07,930
really, we could just listen for
that and zoom when we get

568
00:29:07,930 --> 00:29:11,170
that event, rather than
using double tap or

569
00:29:11,170 --> 00:29:12,810
anything like that.

570
00:29:12,810 --> 00:29:18,720
And pinch makes sense because
you can theoretically pinch

571
00:29:18,720 --> 00:29:22,520
with your hands if you're using
a Leap Motion device.

572
00:29:22,520 --> 00:29:24,780
So it makes sense as an
abstract gesture.

573
00:29:24,780 --> 00:29:27,672

574
00:29:27,672 --> 00:29:29,080
PETE LEPAGE: Cool.

575
00:29:29,080 --> 00:29:32,550
So as you guys were talking
about that, I wrote down one

576
00:29:32,550 --> 00:29:35,310
off-the-cuff idea is, why can't
we just put an attribute

577
00:29:35,310 --> 00:29:38,480
on elements and say, this
element, if the user double

578
00:29:38,480 --> 00:29:44,010
taps on it, anything in here,
we don't get a zoom.

579
00:29:44,010 --> 00:29:45,730
And then you can just say,
all right, great.

580
00:29:45,730 --> 00:29:48,340
Everything in here, if the user
touches on it, that's an

581
00:29:48,340 --> 00:29:51,320
immediate click.

582
00:29:51,320 --> 00:29:52,340
BORIS SMUS: Great idea.

583
00:29:52,340 --> 00:29:56,690
Microsoft implemented it in
IE 10, or maybe IE 9.

584
00:29:56,690 --> 00:30:00,580
There's a CSS property called
ms-touch-action, I think, and

585
00:30:00,580 --> 00:30:04,640
you can configure exactly what
happens when you touch this

586
00:30:04,640 --> 00:30:07,570
particular element
to the extent of

587
00:30:07,570 --> 00:30:09,490
disabling particular gestures.

588
00:30:09,490 --> 00:30:13,700
So you can say no scrolling
on this thing, or no pinch

589
00:30:13,700 --> 00:30:14,720
zooming on it.

590
00:30:14,720 --> 00:30:17,230
And I think it would be great
to standardize this sort of

591
00:30:17,230 --> 00:30:21,570
thing, just because declarative
things are kind of

592
00:30:21,570 --> 00:30:24,040
better from many perspectives.

593
00:30:24,040 --> 00:30:28,608
So, yeah, that's
my perspective.

594
00:30:28,608 --> 00:30:31,560
PETE LEPAGE: Do you know
where it is in the

595
00:30:31,560 --> 00:30:32,730
standardization process?

596
00:30:32,730 --> 00:30:33,610
Or is it even there?

597
00:30:33,610 --> 00:30:35,750
BORIS SMUS: As far as I know,
it's not anywhere.

598
00:30:35,750 --> 00:30:36,530
PETE LEPAGE: OK.

599
00:30:36,530 --> 00:30:36,845
All right.

600
00:30:36,845 --> 00:30:37,920
BORIS SMUS: But I
could be wrong.

601
00:30:37,920 --> 00:30:39,170
Rick?

602
00:30:39,170 --> 00:30:44,682

603
00:30:44,682 --> 00:30:46,255
RICK BYERS: I'm Rick Byers.

604
00:30:46,255 --> 00:30:50,030
I'm the Google person on the
Pointer Events Working Group.

605
00:30:50,030 --> 00:30:54,820
And so the question was the
ability to disable double tap

606
00:30:54,820 --> 00:30:56,210
to zoom with touch
action, right?

607
00:30:56,210 --> 00:30:59,190
So touch action, as we
standardize it right now, has

608
00:30:59,190 --> 00:31:03,120
pan, none, and auto-- pan-x,
pan-y, none, and auto.

609
00:31:03,120 --> 00:31:06,550
And double tap isn't in there,
in particular because to talk

610
00:31:06,550 --> 00:31:08,820
about zooming individual
elements only makes sense in

611
00:31:08,820 --> 00:31:11,420
IE's concept of content zoomable
where you can have an

612
00:31:11,420 --> 00:31:13,800
element that's independently
zoomable from

613
00:31:13,800 --> 00:31:15,140
the rest of the page.

614
00:31:15,140 --> 00:31:17,440
And so we debated adding some
notion of zoom-to-touch

615
00:31:17,440 --> 00:31:19,170
action, but without a notion
of content zoomable, it

616
00:31:19,170 --> 00:31:20,060
doesn't make any sense.

617
00:31:20,060 --> 00:31:22,570
All that really makes sense
is the page itself

618
00:31:22,570 --> 00:31:24,940
being zoomable or not.

619
00:31:24,940 --> 00:31:27,970
So far, in Chrome desktop, for
example, we don't have any

620
00:31:27,970 --> 00:31:29,240
zooming at all.

621
00:31:29,240 --> 00:31:31,100
We're not going to add double
tap, because there's no way in

622
00:31:31,100 --> 00:31:32,710
hell we want to add that
300 millisecond

623
00:31:32,710 --> 00:31:33,750
delay in Chrome desktop.

624
00:31:33,750 --> 00:31:35,610
And in Android, it's
the viewport tag to

625
00:31:35,610 --> 00:31:37,130
disable double tap.

626
00:31:37,130 --> 00:31:37,790
That's where we are right now.

627
00:31:37,790 --> 00:31:39,450
But I think we'll--

628
00:31:39,450 --> 00:31:43,160
we've got to figure out how
can we not delay the click

629
00:31:43,160 --> 00:31:45,150
while still permitting some--

630
00:31:45,150 --> 00:31:47,990
certainly pinch, we should still
permit without disabling

631
00:31:47,990 --> 00:31:48,380
double tap.

632
00:31:48,380 --> 00:31:50,630
So I think maybe adding
something to touch action is

633
00:31:50,630 --> 00:31:52,050
appropriate or some
other mechanism.

634
00:31:52,050 --> 00:31:58,511

635
00:31:58,511 --> 00:31:59,320
PETE LEPAGE: Anybody?

636
00:31:59,320 --> 00:32:01,160
MAIREAD BUCHAN: I kind of feel
like, why don't we just ditch

637
00:32:01,160 --> 00:32:02,170
double tap?

638
00:32:02,170 --> 00:32:04,570
Like, is it really that
much of a win?

639
00:32:04,570 --> 00:32:07,890
If you can pitch to zoom, do
you need two ways to zoom?

640
00:32:07,890 --> 00:32:10,586
Not really.

641
00:32:10,586 --> 00:32:13,670
Let's just filter that
out, fix that.

642
00:32:13,670 --> 00:32:18,198

643
00:32:18,198 --> 00:32:20,440
PETE LEPAGE: All right.

644
00:32:20,440 --> 00:32:22,640
Anybody have anything else they
want to add on that one?

645
00:32:22,640 --> 00:32:23,636
MATT CARUANA GALIZIA:
Just that I agree.

646
00:32:23,636 --> 00:32:26,130
PETE LEPAGE: All right.

647
00:32:26,130 --> 00:32:26,870
What do you guys think?

648
00:32:26,870 --> 00:32:30,490
Should just everybody take
away double tap to zoom?

649
00:32:30,490 --> 00:32:31,418
AUDIENCE: No.

650
00:32:31,418 --> 00:32:32,346
PETE LEPAGE: No.

651
00:32:32,346 --> 00:32:32,810
All right.

652
00:32:32,810 --> 00:32:34,000
Well, there we go.

653
00:32:34,000 --> 00:32:37,560
So it seems that the panelists
disagree with you.

654
00:32:37,560 --> 00:32:40,336
Jake?

655
00:32:40,336 --> 00:32:41,586
Can we get a mic?

656
00:32:41,586 --> 00:32:45,350

657
00:32:45,350 --> 00:32:48,180
AUDIENCE: So it's quite often
if I load a page on my phone

658
00:32:48,180 --> 00:32:53,500
that's not optimized for the
screen size-- it doesn't have

659
00:32:53,500 --> 00:32:54,440
a viewport meta tag--

660
00:32:54,440 --> 00:32:56,950
I'll quite often do the double
tap thing, right, to bring the

661
00:32:56,950 --> 00:33:00,350
paragraph to full width
so I can read it.

662
00:33:00,350 --> 00:33:02,730
But there's probably some way
that we can do around that.

663
00:33:02,730 --> 00:33:08,680
If it does have a viewport tag,
but it isn't fixed zoom,

664
00:33:08,680 --> 00:33:10,360
when the user starts the
interaction we know that

665
00:33:10,360 --> 00:33:13,190
double tap's going to have no
effect because the paragraph

666
00:33:13,190 --> 00:33:14,230
is already full width.

667
00:33:14,230 --> 00:33:17,200
And then we could take
the shortcut there.

668
00:33:17,200 --> 00:33:19,200
We would assume that
one tap is click.

669
00:33:19,200 --> 00:33:20,600
We don't wait 300 milliseconds,
because double

670
00:33:20,600 --> 00:33:22,985
tap is probably not what
they're going to do.

671
00:33:22,985 --> 00:33:25,615

672
00:33:25,615 --> 00:33:30,910
AUDIENCE: And there are also
some touch devices that it

673
00:33:30,910 --> 00:33:33,250
doesn't implement multitouch.

674
00:33:33,250 --> 00:33:38,592
So with the single input, the
double tap solves the problem.

675
00:33:38,592 --> 00:33:39,710
FRANCOIS DAOUST: That's
one point I

676
00:33:39,710 --> 00:33:41,440
wanted to raise as well.

677
00:33:41,440 --> 00:33:44,500
When we talk about input, we
are actually entering a

678
00:33:44,500 --> 00:33:47,480
wonderful world of patents
and that kind of stuff.

679
00:33:47,480 --> 00:33:51,410
And it makes it hard, actually,
to be able to do

680
00:33:51,410 --> 00:33:53,530
whatever you want.

681
00:33:53,530 --> 00:33:57,390
And so indeed, the pinch
couldn't be done in previous

682
00:33:57,390 --> 00:34:02,010
version, at least of other
mobile devices, because of

683
00:34:02,010 --> 00:34:03,470
obvious patents--

684
00:34:03,470 --> 00:34:06,920
or maybe not obvious, actually--
but anyway, because

685
00:34:06,920 --> 00:34:07,490
of patents.

686
00:34:07,490 --> 00:34:10,639
So there's always this side of
the story that we don't like

687
00:34:10,639 --> 00:34:13,360
to talk about and that we don't
like as developers but

688
00:34:13,360 --> 00:34:15,749
that still exists
in this world.

689
00:34:15,749 --> 00:34:16,439
BORIS SMUS: Right.

690
00:34:16,439 --> 00:34:17,830
But I think that's--

691
00:34:17,830 --> 00:34:18,650
hello.

692
00:34:18,650 --> 00:34:19,080
Test.

693
00:34:19,080 --> 00:34:19,510
Test.

694
00:34:19,510 --> 00:34:20,370
FRANCOIS DAOUST: [INAUDIBLE].

695
00:34:20,370 --> 00:34:21,830
BORIS SMUS: Sure.

696
00:34:21,830 --> 00:34:24,780
That said, I think as
developers, there's nothing

697
00:34:24,780 --> 00:34:26,550
that prevents us from
implementing.

698
00:34:26,550 --> 00:34:27,810
[LAUGHTER]

699
00:34:27,810 --> 00:34:31,600
PETE LEPAGE: So obviously,
the audio gods don't

700
00:34:31,600 --> 00:34:32,760
want Boris to speak.

701
00:34:32,760 --> 00:34:32,940
There we go.

702
00:34:32,940 --> 00:34:33,636
All right.

703
00:34:33,636 --> 00:34:34,570
Let's try this again.

704
00:34:34,570 --> 00:34:39,280
BORIS SMUS: So I think the
patents don't affect insomuch

705
00:34:39,280 --> 00:34:41,460
as web developers as
we can implement

706
00:34:41,460 --> 00:34:42,750
our own gesture handlers.

707
00:34:42,750 --> 00:34:45,080
They're just not going to
be available natively in

708
00:34:45,080 --> 00:34:48,180
platforms for any foreseeable
future.

709
00:34:48,180 --> 00:34:51,340
But we can still make our own
gesture libraries, and there's

710
00:34:51,340 --> 00:34:52,620
many of them out there.

711
00:34:52,620 --> 00:34:56,100
So that shouldn't
be stopping any

712
00:34:56,100 --> 00:34:57,350
development in this direction.

713
00:34:57,350 --> 00:35:00,502

714
00:35:00,502 --> 00:35:03,390
FRANCOIS DAOUST: What it stops
usually is standardization.

715
00:35:03,390 --> 00:35:07,310
It's where things stop.

716
00:35:07,310 --> 00:35:12,650
And gestures have been stopped
for that precise reason, at

717
00:35:12,650 --> 00:35:15,012
W3C, at least.

718
00:35:15,012 --> 00:35:18,750
There are other examples.

719
00:35:18,750 --> 00:35:19,320
PETE LEPAGE: All right.

720
00:35:19,320 --> 00:35:20,950
Anything else?

721
00:35:20,950 --> 00:35:21,600
All right.

722
00:35:21,600 --> 00:35:23,190
Let's pop down to the
next question.

723
00:35:23,190 --> 00:35:25,460
This is one that I added because
I think it's a really

724
00:35:25,460 --> 00:35:30,340
important question that
gets addressed.

725
00:35:30,340 --> 00:35:35,170
As web developers, how can we
test our sites if we don't own

726
00:35:35,170 --> 00:35:38,160
a touch PC or a touch
laptop, right?

727
00:35:38,160 --> 00:35:40,350
How can we be testing our sites
to see how they're going

728
00:35:40,350 --> 00:35:42,110
to interact on some
of these things?

729
00:35:42,110 --> 00:35:45,210
Obviously, going down to the
local computer store and

730
00:35:45,210 --> 00:35:49,350
testing your web app on there
and then going home isn't

731
00:35:49,350 --> 00:35:50,600
going to work.

732
00:35:50,600 --> 00:35:52,618

733
00:35:52,618 --> 00:35:56,240
MAIREAD BUCHAN: Well, in my
experience, the only way to

734
00:35:56,240 --> 00:36:00,530
develop, to test on a device
is to have in your hand.

735
00:36:00,530 --> 00:36:03,180
And if you really can't afford
to that, then I think you need

736
00:36:03,180 --> 00:36:06,840
to get testing labs or these
kind of browser shop places

737
00:36:06,840 --> 00:36:08,200
where you've got someone
else doing it

738
00:36:08,200 --> 00:36:09,100
with an actual device.

739
00:36:09,100 --> 00:36:13,960
I haven't found any emulator or
simulator that was really

740
00:36:13,960 --> 00:36:14,510
that useful.

741
00:36:14,510 --> 00:36:17,680
And even if you're looking at
something on a screen, and

742
00:36:17,680 --> 00:36:20,760
you've got an iPad-shaped thing,
like our designers were

743
00:36:20,760 --> 00:36:21,520
designing things.

744
00:36:21,520 --> 00:36:24,420
And then when the QA actually
had an iPad in his hand, his

745
00:36:24,420 --> 00:36:27,580
thumb, the way he was holding
the device, actually obscured

746
00:36:27,580 --> 00:36:30,800
part of the design, which you
can't mimic unless you're

747
00:36:30,800 --> 00:36:33,540
really holding an
actual thing.

748
00:36:33,540 --> 00:36:35,840
I think if you can't afford
every device, and if you're a

749
00:36:35,840 --> 00:36:38,740
sole trader, there's no
way you could do that.

750
00:36:38,740 --> 00:36:42,300
You're going to have to
put an extra line

751
00:36:42,300 --> 00:36:45,475
item in your budget.

752
00:36:45,475 --> 00:36:46,710
FRANCOIS DAOUST: Yeah.

753
00:36:46,710 --> 00:36:51,250
Well, I'm afraid there's not
many other solutions.

754
00:36:51,250 --> 00:36:54,410
We do a lot of development on
connected TVs, for instance.

755
00:36:54,410 --> 00:36:59,590
And you try the emulators.

756
00:36:59,590 --> 00:37:04,420
They just don't work as the
actual TV, so you really have

757
00:37:04,420 --> 00:37:08,290
no other choice than to have the
set-top box, the TV, the

758
00:37:08,290 --> 00:37:10,330
whatever in your room
and try it.

759
00:37:10,330 --> 00:37:15,120
You can just delay the time at
which you start to try to test

760
00:37:15,120 --> 00:37:20,630
the app on a natural device,
but it has to be done,

761
00:37:20,630 --> 00:37:23,192
unfortunately.

762
00:37:23,192 --> 00:37:25,540
MATT CARUANA GALIZIA: At the FT
we use a testing framework

763
00:37:25,540 --> 00:37:31,710
called eggPlant to test using
the iOS simulator, and it

764
00:37:31,710 --> 00:37:32,790
seems to work quite well.

765
00:37:32,790 --> 00:37:38,080
It's just very difficult to get
using, because you have to

766
00:37:38,080 --> 00:37:40,705
learn their scripting language,
script the device.

767
00:37:40,705 --> 00:37:41,955
It's very labor intensive.

768
00:37:41,955 --> 00:37:44,690

769
00:37:44,690 --> 00:37:47,570
BORIS SMUS: I think it's worth
mentioning that the simplest

770
00:37:47,570 --> 00:37:51,820
thing you can do, if you're
especially a content-oriented

771
00:37:51,820 --> 00:37:55,800
site, is you can enable
touch events in the

772
00:37:55,800 --> 00:37:57,340
Chrome Developer Tools.

773
00:37:57,340 --> 00:37:59,770
So it's just a tick box
in the settings.

774
00:37:59,770 --> 00:38:03,690
And if your site doesn't work
with that enabled-- basically,

775
00:38:03,690 --> 00:38:06,550
what it does is it creates a
touch-equivalent event for

776
00:38:06,550 --> 00:38:07,710
each mouse event.

777
00:38:07,710 --> 00:38:11,090
And if your site doesn't work
there, then it's not

778
00:38:11,090 --> 00:38:12,180
guaranteed--

779
00:38:12,180 --> 00:38:14,180
or basically, if it doesn't work
there, it's guaranteed

780
00:38:14,180 --> 00:38:17,350
not to work on a
mobile device.

781
00:38:17,350 --> 00:38:22,020
So you don't have the opposite
guarantee, but

782
00:38:22,020 --> 00:38:24,340
it's at least something.

783
00:38:24,340 --> 00:38:26,810
The other thing is I would--

784
00:38:26,810 --> 00:38:30,960
pardon my shameless plug, but
basically, there's a GitHub

785
00:38:30,960 --> 00:38:37,440
repo that lets you take your
multitouch trackpad on your

786
00:38:37,440 --> 00:38:42,690
Mac device and just essentially
pass those events

787
00:38:42,690 --> 00:38:46,410
into the browser, synthesizing
multitouch events.

788
00:38:46,410 --> 00:38:49,460
If you want to check it out,
it's called MagicTouch, and

789
00:38:49,460 --> 00:38:51,302
it'll work on your Mac.

790
00:38:51,302 --> 00:38:52,552
End of plug.

791
00:38:52,552 --> 00:38:56,102

792
00:38:56,102 --> 00:38:58,174
BORIS SMUS: Rick.

793
00:38:58,174 --> 00:38:59,630
PETE LEPAGE: Mic coming
up behind you.

794
00:38:59,630 --> 00:39:01,862
MATT CARUANA GALIZIA:
Behind you.

795
00:39:01,862 --> 00:39:04,820
RICK BYERS: There's just one
more really important piece I

796
00:39:04,820 --> 00:39:06,910
think I just wanted to mention,
that for this common

797
00:39:06,910 --> 00:39:12,110
case that Matt was discussing
about a site that when you run

798
00:39:12,110 --> 00:39:14,230
it on a computer with
touch and mouse,

799
00:39:14,230 --> 00:39:15,630
the mouse stops working.

800
00:39:15,630 --> 00:39:19,180
That's the case we see all
the time in Chrome on

801
00:39:19,180 --> 00:39:20,290
touch-enabled laptops.

802
00:39:20,290 --> 00:39:21,650
That's actually really
easy to test.

803
00:39:21,650 --> 00:39:24,970
You can run Chrome with the
flag, dash, dash, touch

804
00:39:24,970 --> 00:39:25,790
events, colon, enable.

805
00:39:25,790 --> 00:39:27,910
From about:flags, you
can turn that on.

806
00:39:27,910 --> 00:39:30,090
We really would like to
have Chrome always

807
00:39:30,090 --> 00:39:31,090
support touch events.

808
00:39:31,090 --> 00:39:33,150
The problem is, people conflate
the idea "does the

809
00:39:33,150 --> 00:39:35,490
browser support touch events"
with "is there a touchscreen

810
00:39:35,490 --> 00:39:36,090
attached?"

811
00:39:36,090 --> 00:39:38,150
And in theory, we want the
browser to always support

812
00:39:38,150 --> 00:39:39,640
touch events, because you
could plug in a USB

813
00:39:39,640 --> 00:39:40,960
touchscreen any time.

814
00:39:40,960 --> 00:39:43,140
And we can't just suddenly start
have [? window down ?]

815
00:39:43,140 --> 00:39:44,440
on touch.

816
00:39:44,440 --> 00:39:46,940
We can't change whether or not
the browser supports touch

817
00:39:46,940 --> 00:39:49,790
events during the lifetime
of a renderer process.

818
00:39:49,790 --> 00:39:51,670
We can only do it on startup.

819
00:39:51,670 --> 00:39:53,860
It would confuse the page,
even if we could do.

820
00:39:53,860 --> 00:39:56,120
So we'd love to be able
to just say-- in

821
00:39:56,120 --> 00:39:56,890
fact, we've done it.

822
00:39:56,890 --> 00:39:58,970
I think for Chrome 22
for a while, we

823
00:39:58,970 --> 00:39:59,720
supported touch events.

824
00:39:59,720 --> 00:40:01,790
Everyone complained that
sites were broken.

825
00:40:01,790 --> 00:40:03,360
I'm like, yeah, it's because
they assume that supporting

826
00:40:03,360 --> 00:40:05,200
touch events means that there's
touchscreen attached

827
00:40:05,200 --> 00:40:06,110
when it doesn't.

828
00:40:06,110 --> 00:40:07,290
So please, turn that flag on.

829
00:40:07,290 --> 00:40:08,220
Run with it on all the time.

830
00:40:08,220 --> 00:40:10,210
It doesn't hurt anything except
it might break your

831
00:40:10,210 --> 00:40:11,490
site because you've got
bugs in your site.

832
00:40:11,490 --> 00:40:14,577

833
00:40:14,577 --> 00:40:17,660
BORIS SMUS: So actually
on that, it's sort

834
00:40:17,660 --> 00:40:19,330
of interesting when--

835
00:40:19,330 --> 00:40:21,630
I think we're getting to a place
where there's a lot of

836
00:40:21,630 --> 00:40:24,270
possible permutations of
input that's available.

837
00:40:24,270 --> 00:40:26,740
And there's no real
way to know what's

838
00:40:26,740 --> 00:40:30,815
actually hooked up.

839
00:40:30,815 --> 00:40:31,540
I don't know.

840
00:40:31,540 --> 00:40:35,040
Maybe I'm the only one that's
kind of hit this, but it seems

841
00:40:35,040 --> 00:40:37,880
like sort of a bigger issue
for the web platform.

842
00:40:37,880 --> 00:40:38,640
Just--

843
00:40:38,640 --> 00:40:42,490
yeah, no real point here.

844
00:40:42,490 --> 00:40:43,710
PETE LEPAGE: All right.

845
00:40:43,710 --> 00:40:45,764
Anything else we want
to add to this?

846
00:40:45,764 --> 00:40:46,890
All right.

847
00:40:46,890 --> 00:40:48,360
Let's pop down to the
next question.

848
00:40:48,360 --> 00:40:50,730
And I think it's actually going
back to the sort of

849
00:40:50,730 --> 00:40:54,140
standardization comments we've
had a couple of times.

850
00:40:54,140 --> 00:40:57,110
But should we started working
on this standardizing of

851
00:40:57,110 --> 00:41:00,490
spatial and gestural input from
the upcoming wave of 3D

852
00:41:00,490 --> 00:41:03,602
motion sensing devices
like Leap Motion?

853
00:41:03,602 --> 00:41:06,690
MAIREAD BUCHAN: And so I was
talking to a research

854
00:41:06,690 --> 00:41:09,270
department at Kingston
University, and they deal with

855
00:41:09,270 --> 00:41:10,900
human-computer interaction.

856
00:41:10,900 --> 00:41:16,850
So they've been working with
multimillion pound software

857
00:41:16,850 --> 00:41:21,020
and hardware to do human pose
and gesture detection.

858
00:41:21,020 --> 00:41:24,780
And they've written a couple
of EU standards for gesture

859
00:41:24,780 --> 00:41:26,860
and also human body pose.

860
00:41:26,860 --> 00:41:32,090
So that kind of research has
already existed, not in the

861
00:41:32,090 --> 00:41:35,840
web development world but
in the HCI world, for

862
00:41:35,840 --> 00:41:37,520
quite a long time.

863
00:41:37,520 --> 00:41:40,470
If I was going to see a standard
for us to work with

864
00:41:40,470 --> 00:41:44,740
Leap and Kinect, I would like
it to be following in the

865
00:41:44,740 --> 00:41:46,420
paths of other people's
research.

866
00:41:46,420 --> 00:41:49,340
I don't want to reinvent the
wheel for that kind of thing.

867
00:41:49,340 --> 00:41:53,480

868
00:41:53,480 --> 00:41:55,260
MATT CARUANA GALIZIA:
I agree with that.

869
00:41:55,260 --> 00:41:58,330
For most use cases, developers
will just want to listen to

870
00:41:58,330 --> 00:41:58,970
the intent.

871
00:41:58,970 --> 00:42:03,120
For example, in the few use
cases right now where a Leap

872
00:42:03,120 --> 00:42:06,040
Motion device is attached, we
just want our website to

873
00:42:06,040 --> 00:42:08,930
continue working if we're
listening for

874
00:42:08,930 --> 00:42:11,340
events on links, say.

875
00:42:11,340 --> 00:42:17,220
But for applications that
specifically target--

876
00:42:17,220 --> 00:42:20,070
meant to be used with Leap
Motion devices or the Kinect,

877
00:42:20,070 --> 00:42:25,220
say, then really need a standard
way of dealing with

878
00:42:25,220 --> 00:42:26,770
input from these devices.

879
00:42:26,770 --> 00:42:28,720
The market is probably
going to grow.

880
00:42:28,720 --> 00:42:31,990
There are going to be
many new devices.

881
00:42:31,990 --> 00:42:35,890
We can't just ship all the
different JavaScript libraries

882
00:42:35,890 --> 00:42:38,060
for every single device
with our application.

883
00:42:38,060 --> 00:42:40,356
It's just not scalable.

884
00:42:40,356 --> 00:42:41,260
BORIS SMUS: Yeah.

885
00:42:41,260 --> 00:42:44,810
I would sort of agree
in spirit with the

886
00:42:44,810 --> 00:42:48,260
standardization idea, but I
really do think it's early

887
00:42:48,260 --> 00:42:51,020
days for these kinds
of inputs.

888
00:42:51,020 --> 00:42:53,650
And I think before standardizing
it, it's

889
00:42:53,650 --> 00:42:57,660
worthwhile just to let a million
flowers bloom and just

890
00:42:57,660 --> 00:43:02,160
to see what the commonalities
are and what the useful things

891
00:43:02,160 --> 00:43:05,110
are for standardization before
we move in that path, because

892
00:43:05,110 --> 00:43:06,360
it's going to slow us down.

893
00:43:06,360 --> 00:43:09,172

894
00:43:09,172 --> 00:43:13,700
PETE LEPAGE: Matt, I want to
go back on the same path of

895
00:43:13,700 --> 00:43:16,890
something that you said that
kind of jogged my mind and I

896
00:43:16,890 --> 00:43:18,350
thought was kind
of interesting.

897
00:43:18,350 --> 00:43:21,040
Should we maybe think about with
the PointerEvents spec

898
00:43:21,040 --> 00:43:24,660
just adding a z-coordinate
to it?

899
00:43:24,660 --> 00:43:25,520
MATT CARUANA GALIZIA: Yeah.

900
00:43:25,520 --> 00:43:27,450
I think that make sense.

901
00:43:27,450 --> 00:43:29,790
Why not, really?

902
00:43:29,790 --> 00:43:32,160
PETE LEPAGE: Would something
like that work for Leap and

903
00:43:32,160 --> 00:43:35,080
all of these other things,
potentially?

904
00:43:35,080 --> 00:43:39,390
MATT CARUANA GALIZIA: It would
work in a limited sense.

905
00:43:39,390 --> 00:43:44,200
It wouldn't allow you to make
the best use of the Leap

906
00:43:44,200 --> 00:43:46,540
Motion device.

907
00:43:46,540 --> 00:43:52,440
But for doing basic things, like
manipulating something,

908
00:43:52,440 --> 00:43:57,160
let's say a graphic within a
3D plane, then that works.

909
00:43:57,160 --> 00:44:00,616
For more complex gestures, then
of course, it will be a

910
00:44:00,616 --> 00:44:03,910
bit more difficult to use
pointers in that sense.

911
00:44:03,910 --> 00:44:05,630
You'd need something a bit
more sophisticated.

912
00:44:05,630 --> 00:44:08,295

913
00:44:08,295 --> 00:44:11,170
MAIREAD BUCHAN: I think the way
I see it, there's a couple

914
00:44:11,170 --> 00:44:13,490
of different kinds of
applications that you might

915
00:44:13,490 --> 00:44:16,770
want to use, a 3D motion-sensor

916
00:44:16,770 --> 00:44:19,045
device and the internet.

917
00:44:19,045 --> 00:44:22,260
So one kind of use case is that
you're building a website

918
00:44:22,260 --> 00:44:23,200
that someone's going
to browse.

919
00:44:23,200 --> 00:44:25,090
So they're swiping carousels,
and they're

920
00:44:25,090 --> 00:44:26,110
scrolling the page.

921
00:44:26,110 --> 00:44:28,610
And that's quite traditional
web development.

922
00:44:28,610 --> 00:44:30,920
Or there's another aspect
where you might be doing

923
00:44:30,920 --> 00:44:35,480
something more in a 3D
environment, so gaming and

924
00:44:35,480 --> 00:44:41,640
things where you need inertia
and speed and like also, 3D

925
00:44:41,640 --> 00:44:44,960
motion does kind of tilt,
and rotation of a point.

926
00:44:44,960 --> 00:44:46,750
So it's not just x, y, z.

927
00:44:46,750 --> 00:44:49,090
There's actually a lot of other
information, and that's

928
00:44:49,090 --> 00:44:50,570
relevant to a 3D world.

929
00:44:50,570 --> 00:44:53,450
But it's not really relevant to
someone browsing a web page

930
00:44:53,450 --> 00:44:56,840
or reading a magazine
on their television.

931
00:44:56,840 --> 00:45:00,100
So what kind of application
you're developing, it depends

932
00:45:00,100 --> 00:45:01,530
how much information you need.

933
00:45:01,530 --> 00:45:07,030
So pointer is really good for
websites, and there's other

934
00:45:07,030 --> 00:45:11,412
things that would be relevant
for other kinds.

935
00:45:11,412 --> 00:45:12,360
BORIS SMUS: I agree.

936
00:45:12,360 --> 00:45:14,920
And I would actually be wary
of adding a z-coordinate to

937
00:45:14,920 --> 00:45:20,010
pointer events, partly just
because it's unclear what the

938
00:45:20,010 --> 00:45:22,700
units would be for
all this stuff.

939
00:45:22,700 --> 00:45:26,640
You're breaking the connection
of a mapping-to-a-screen

940
00:45:26,640 --> 00:45:28,140
coordinate.

941
00:45:28,140 --> 00:45:31,200
As soon as you're dealing with
tracking real world stuff,

942
00:45:31,200 --> 00:45:33,450
it's in some different
coordinate systems that's

943
00:45:33,450 --> 00:45:34,880
basically--

944
00:45:34,880 --> 00:45:38,300
if you can bring it back to
screen space, you're doing it

945
00:45:38,300 --> 00:45:39,740
with some weird transform.

946
00:45:39,740 --> 00:45:41,960
But there's some other
set of coordinates.

947
00:45:41,960 --> 00:45:45,810
Typically for a depth cam, it's
x, y, z, in millimeters,

948
00:45:45,810 --> 00:45:49,390
which would be very confusing to
suddenly change your units

949
00:45:49,390 --> 00:45:51,070
to millimeters in
pointer spec.

950
00:45:51,070 --> 00:45:54,745
So my vote for keeping
pointers clean.

951
00:45:54,745 --> 00:45:57,788

952
00:45:57,788 --> 00:45:59,940
PETE LEPAGE: Francois, do you
want to weigh in on that one?

953
00:45:59,940 --> 00:46:00,370
FRANCOIS DAOUST: [INAUDIBLE].

954
00:46:00,370 --> 00:46:01,091
PETE LEPAGE: All right.

955
00:46:01,091 --> 00:46:01,395
All right.

956
00:46:01,395 --> 00:46:04,496
FRANCOIS DAOUST: [INAUDIBLE].

957
00:46:04,496 --> 00:46:05,310
PETE LEPAGE: All right.

958
00:46:05,310 --> 00:46:07,710
So pop down to our
next question.

959
00:46:07,710 --> 00:46:11,240
What will be the equivalent
event for hover mouseover for

960
00:46:11,240 --> 00:46:12,660
touch devices?

961
00:46:12,660 --> 00:46:14,290
Should we abandon the
hover event when

962
00:46:14,290 --> 00:46:15,660
considering touch devices?

963
00:46:15,660 --> 00:46:19,167

964
00:46:19,167 --> 00:46:22,880
FRANCOIS DAOUST: I guess that
could happen in the future.

965
00:46:22,880 --> 00:46:25,840
You can already do that, some
kind of presence detection of

966
00:46:25,840 --> 00:46:30,290
the finger, with several
systems, infrared or--

967
00:46:30,290 --> 00:46:31,420
what's it's called?

968
00:46:31,420 --> 00:46:32,640
Ultrasound.

969
00:46:32,640 --> 00:46:34,830
There are some systems that
allow you to detect the

970
00:46:34,830 --> 00:46:38,860
presence of a finger without
actually touching the screen.

971
00:46:38,860 --> 00:46:44,170
But it has more limited use than
hover, and it's supposed

972
00:46:44,170 --> 00:46:49,470
that the user is not shaking and
is actually pointing his

973
00:46:49,470 --> 00:46:50,720
finger correctly.

974
00:46:50,720 --> 00:46:52,820

975
00:46:52,820 --> 00:46:55,250
We should not close the door
to that possibility, but I

976
00:46:55,250 --> 00:46:58,080
don't think that's a main
use case right now.

977
00:46:58,080 --> 00:47:00,170
BORIS SMUS: I think it's
important that we don't rely

978
00:47:00,170 --> 00:47:06,720
on hover for just the general
web, again, because of mixed

979
00:47:06,720 --> 00:47:09,160
modalities, possibly of input.

980
00:47:09,160 --> 00:47:11,370
If you rely on hover, generally
touch devices are

981
00:47:11,370 --> 00:47:13,750
not going to be able to
see whatever's there.

982
00:47:13,750 --> 00:47:16,500
It's a very clunky interaction
to have this.

983
00:47:16,500 --> 00:47:19,880
You can activate the hover
state, the CSS hover state, by

984
00:47:19,880 --> 00:47:22,360
doing this weird action.

985
00:47:22,360 --> 00:47:25,540
You press down on the link, and
then you move away from it

986
00:47:25,540 --> 00:47:27,480
before it long presses, or
something like that.

987
00:47:27,480 --> 00:47:29,390
And then you get the
hover state.

988
00:47:29,390 --> 00:47:32,430
But obviously this is not
something that we want to do

989
00:47:32,430 --> 00:47:34,080
or have people do.

990
00:47:34,080 --> 00:47:37,170
So I do think that
it's important.

991
00:47:37,170 --> 00:47:40,020
Though there's technology coming
to make this happen,

992
00:47:40,020 --> 00:47:42,630
it's not going to
happen tomorrow.

993
00:47:42,630 --> 00:47:45,950
You should be very aware of
hover states in touch and

994
00:47:45,950 --> 00:47:48,442
don't do it.

995
00:47:48,442 --> 00:47:49,610
PETE LEPAGE: There
a comment back--

996
00:47:49,610 --> 00:47:52,320
AUDIENCE: Actually, I
ask a question, yes.

997
00:47:52,320 --> 00:47:59,110
And the reason I ask is, so my
wife has a Samsung Note, which

998
00:47:59,110 --> 00:48:01,250
comes with a pen.

999
00:48:01,250 --> 00:48:05,120
Because it comes with pen, pen
can do the kind of hover

1000
00:48:05,120 --> 00:48:05,320
equivalent.

1001
00:48:05,320 --> 00:48:10,010
When it comes too close to the
surface, it mimics hover.

1002
00:48:10,010 --> 00:48:13,670
And also, when you do a drawing
in something like

1003
00:48:13,670 --> 00:48:15,960
Wacom they also have
the hover.

1004
00:48:15,960 --> 00:48:18,200
And it's very critical,
especially when you start

1005
00:48:18,200 --> 00:48:20,470
doing [? data ?] visualization
or something, you don't want

1006
00:48:20,470 --> 00:48:23,130
to touch everything, because
you just want to glance the

1007
00:48:23,130 --> 00:48:24,110
information.

1008
00:48:24,110 --> 00:48:26,800
Then you need a [INAUDIBLE]

1009
00:48:26,800 --> 00:48:31,380
information, which I don't
want to touch everything.

1010
00:48:31,380 --> 00:48:36,400
So I think hover is kind of
getting neglected, especially

1011
00:48:36,400 --> 00:48:36,960
in the touch.

1012
00:48:36,960 --> 00:48:40,070
You think a touch panel
enhances the input--

1013
00:48:40,070 --> 00:48:40,860
PETE LEPAGE: Yeah.

1014
00:48:40,860 --> 00:48:41,570
AUDIENCE: --but it's actually
one [? other ?]

1015
00:48:41,570 --> 00:48:41,760
thing.

1016
00:48:41,760 --> 00:48:42,450
It's decreasing.

1017
00:48:42,450 --> 00:48:43,240
PETE LEPAGE: Yeah.

1018
00:48:43,240 --> 00:48:43,550
Yeah.

1019
00:48:43,550 --> 00:48:45,350
I think that's a really
valid point.

1020
00:48:45,350 --> 00:48:48,350
MAIREAD BUCHAN: I think it's
kind of highlighting the

1021
00:48:48,350 --> 00:48:51,610
problem of like a kind of--

1022
00:48:51,610 --> 00:48:53,820
I don't want to use the word
"semantics," but I can't think

1023
00:48:53,820 --> 00:48:54,670
of anything better--

1024
00:48:54,670 --> 00:48:59,650
like a hover with a mouse on
a 2D screen is not really a

1025
00:48:59,650 --> 00:49:00,160
hover at all.

1026
00:49:00,160 --> 00:49:02,860
That's a mouse entering
a bounded area.

1027
00:49:02,860 --> 00:49:05,260
It's not hovering just above it
because you've only got two

1028
00:49:05,260 --> 00:49:07,370
dimensions.

1029
00:49:07,370 --> 00:49:11,120
What's a hover in a 3D world
is different to a

1030
00:49:11,120 --> 00:49:12,010
hover in a 2D world.

1031
00:49:12,010 --> 00:49:16,700
And actually, it should be
pointer Enter before pointer

1032
00:49:16,700 --> 00:49:17,920
is activated.

1033
00:49:17,920 --> 00:49:20,990
And your active is your click,
and your Enter is your hover.

1034
00:49:20,990 --> 00:49:24,370
But we need to move away from
that kind of terminology,

1035
00:49:24,370 --> 00:49:26,570
because it is confusing.

1036
00:49:26,570 --> 00:49:27,820
It's a mixed metaphor.

1037
00:49:27,820 --> 00:49:30,330

1038
00:49:30,330 --> 00:49:32,790
I like hover, but I tell my
designers they're not allowed

1039
00:49:32,790 --> 00:49:35,802
to use it anymore.

1040
00:49:35,802 --> 00:49:37,530
PETE LEPAGE: We've
got time for, I

1041
00:49:37,530 --> 00:49:38,780
think, one more question.

1042
00:49:38,780 --> 00:49:41,950

1043
00:49:41,950 --> 00:49:44,420
So we'll go for this last one.

1044
00:49:44,420 --> 00:49:47,280
Smooth scrolling is critical
for a good touchscreen

1045
00:49:47,280 --> 00:49:48,180
experience.

1046
00:49:48,180 --> 00:49:50,520
What are some of the common
pitfalls for introducing

1047
00:49:50,520 --> 00:49:52,750
scroll jank to touch input?

1048
00:49:52,750 --> 00:49:55,396

1049
00:49:55,396 --> 00:49:57,850
BORIS SMUS: So one of the common
things people tend to

1050
00:49:57,850 --> 00:50:02,330
do is do a bunch of stuff
in their input handlers.

1051
00:50:02,330 --> 00:50:05,470
So this breaks down really
quickly with multitouch,

1052
00:50:05,470 --> 00:50:09,765
because you're having your
touch move events firing

1053
00:50:09,765 --> 00:50:11,380
basically at a rate proportional
to the number of

1054
00:50:11,380 --> 00:50:12,770
fingers on your screen.

1055
00:50:12,770 --> 00:50:15,420
So you end up having
a flood of--

1056
00:50:15,420 --> 00:50:16,810
I don't know-- something
like--

1057
00:50:16,810 --> 00:50:21,940
I've seen it go up to, like,
200 fps touch input events.

1058
00:50:21,940 --> 00:50:26,860
So if you're trying to render
at 200 fps, you're obviously

1059
00:50:26,860 --> 00:50:31,210
going to be throttling your
rendering engine.

1060
00:50:31,210 --> 00:50:35,270
The workaround to this is use
RequestAnimationFrame, set

1061
00:50:35,270 --> 00:50:40,960
state in your input handler, and
then render on render as

1062
00:50:40,960 --> 00:50:42,210
opposed to on input.

1063
00:50:42,210 --> 00:50:45,556

1064
00:50:45,556 --> 00:50:47,080
PETE LEPAGE: Anybody else
got anything they

1065
00:50:47,080 --> 00:50:48,660
want to add to that?

1066
00:50:48,660 --> 00:50:49,090
Who's there?

1067
00:50:49,090 --> 00:50:49,650
RICK BYERS: Rick.

1068
00:50:49,650 --> 00:50:50,640
PETE LEPAGE: All right.

1069
00:50:50,640 --> 00:50:51,910
Can we get a mic over
there real quick.

1070
00:50:51,910 --> 00:50:54,540

1071
00:50:54,540 --> 00:50:55,400
RICK BYERS: I'm sorry.

1072
00:50:55,400 --> 00:50:58,840
This is such a big problem I
can't help not speak up again.

1073
00:50:58,840 --> 00:51:00,770
I think people often don't
realize the implication of

1074
00:51:00,770 --> 00:51:02,260
putting a touch handler
on your page.

1075
00:51:02,260 --> 00:51:05,190
So if you're using touch events,
the model is that the

1076
00:51:05,190 --> 00:51:07,390
browser can't decide whether
or not to scroll until it's

1077
00:51:07,390 --> 00:51:10,010
dispatched the touch
starter-touch move event to

1078
00:51:10,010 --> 00:51:11,110
you and waited to see if
you're going to call

1079
00:51:11,110 --> 00:51:11,770
preventDefault.

1080
00:51:11,770 --> 00:51:13,820
And if you preventDefault on the
touch starter-touch move,

1081
00:51:13,820 --> 00:51:15,040
that means you're canceling
the scroll.

1082
00:51:15,040 --> 00:51:17,040
You might even be in the middle
of the scroll, and you

1083
00:51:17,040 --> 00:51:18,710
preventDefault to move, and it
means we have to cancel the

1084
00:51:18,710 --> 00:51:21,520
scroll, which means in modern
browsers, we try to do as much

1085
00:51:21,520 --> 00:51:23,700
scrolling as possible
on the GPU thread.

1086
00:51:23,700 --> 00:51:26,350
Which means we've got to block
the GPU thread, synchronize

1087
00:51:26,350 --> 00:51:27,680
with the main thread that might
be in the middle of

1088
00:51:27,680 --> 00:51:30,660
JavaScript or loading a page to
wait to see what your touch

1089
00:51:30,660 --> 00:51:31,940
handler is going to do
before we can go

1090
00:51:31,940 --> 00:51:32,940
back and undo scrolling.

1091
00:51:32,940 --> 00:51:34,020
And it's a huge problem.

1092
00:51:34,020 --> 00:51:37,240
So the key guidance
I would give is--

1093
00:51:37,240 --> 00:51:40,070
what we've done in the recent
versions of Chrome and what

1094
00:51:40,070 --> 00:51:43,540
iOS does is it's got region
tracking so that the GPU

1095
00:51:43,540 --> 00:51:45,860
thread knows which regions
of the page have a

1096
00:51:45,860 --> 00:51:47,060
touch handler on it.

1097
00:51:47,060 --> 00:51:49,590
So if you confine your touch
handlers to just the elements

1098
00:51:49,590 --> 00:51:52,890
that really need to have touch
handlers, then we can only

1099
00:51:52,890 --> 00:51:54,680
introduce the jank when
you touch those.

1100
00:51:54,680 --> 00:51:57,530
If you put a touch-move handler
on your document, it

1101
00:51:57,530 --> 00:51:59,580
means that every single scroll
has got a block on the main

1102
00:51:59,580 --> 00:52:01,710
thread, and it's going to be
almost impossible to have

1103
00:52:01,710 --> 00:52:03,990
smooth scrolling.

1104
00:52:03,990 --> 00:52:05,570
This is one of the things I
think is a problem with the

1105
00:52:05,570 --> 00:52:06,300
touch event model.

1106
00:52:06,300 --> 00:52:08,640
Pointer event solves this.

1107
00:52:08,640 --> 00:52:11,744
PETE LEPAGE: There's a
comment back there.

1108
00:52:11,744 --> 00:52:12,680
AUDIENCE: Hi.

1109
00:52:12,680 --> 00:52:14,370
It was just related to
what you were saying.

1110
00:52:14,370 --> 00:52:16,850
How does that translate
through to clicks?

1111
00:52:16,850 --> 00:52:19,300
Is it just touch, or what
happens when you've got the

1112
00:52:19,300 --> 00:52:21,955
simulated clicks from the touch
events with scrolling?

1113
00:52:21,955 --> 00:52:24,822

1114
00:52:24,822 --> 00:52:25,590
PETE LEPAGE: Sorry.

1115
00:52:25,590 --> 00:52:26,520
Just to make sure
I understand.

1116
00:52:26,520 --> 00:52:28,250
What happens when you have
simulated clicks?

1117
00:52:28,250 --> 00:52:30,925
AUDIENCE: So if you've got a
click handler element that

1118
00:52:30,925 --> 00:52:33,355
you're using to scroll, does
exactly the same thing apply,

1119
00:52:33,355 --> 00:52:33,703
or it just--

1120
00:52:33,703 --> 00:52:37,330
RICK BYERS: It's just touch
handlers, because click is

1121
00:52:37,330 --> 00:52:40,280
triggered by a tap gesture, and
so there's no ambiguity

1122
00:52:40,280 --> 00:52:41,990
between scrolling and tapping.

1123
00:52:41,990 --> 00:52:43,483
So you can have a tap handler,
you can have

1124
00:52:43,483 --> 00:52:44,870
a mouse-down handler.

1125
00:52:44,870 --> 00:52:46,900
In theory, mouse wheel
has the same problem.

1126
00:52:46,900 --> 00:52:49,740
In theory, mouse wheels are
blocked on JavaScript.

1127
00:52:49,740 --> 00:52:51,640
If there's a JavaScript
handler, we have to.

1128
00:52:51,640 --> 00:52:51,970
But--

1129
00:52:51,970 --> 00:52:52,480
AUDIENCE: [INAUDIBLE]--

1130
00:52:52,480 --> 00:52:54,120
RICK BYERS: --all browser
implementations

1131
00:52:54,120 --> 00:52:55,370
today always block.

1132
00:52:55,370 --> 00:52:57,070
They don't do the region
tracking for mouse wheel,

1133
00:52:57,070 --> 00:52:59,310
because there's a psychological
effect.

1134
00:52:59,310 --> 00:53:01,370
Scrolling with your finger, you
really notice the jank.

1135
00:53:01,370 --> 00:53:03,040
Scrolling with your mouse wheel
or the trackpad, you

1136
00:53:03,040 --> 00:53:04,070
don't notice it so much
because you're

1137
00:53:04,070 --> 00:53:05,450
not physically connected.

1138
00:53:05,450 --> 00:53:08,050
So in theory, the problem exists
for mouse wheel, and we

1139
00:53:08,050 --> 00:53:11,200
said we're probably going to
apply the same region tracking

1140
00:53:11,200 --> 00:53:12,830
we've done for touch to
mouse wheel in Chrome.

1141
00:53:12,830 --> 00:53:14,390
We just haven't done it yet,
because it's not as important

1142
00:53:14,390 --> 00:53:15,640
because of that psychological
effect.

1143
00:53:15,640 --> 00:53:18,900

1144
00:53:18,900 --> 00:53:21,000
FRANCOIS DAOUST: I know the
discussion has focused on

1145
00:53:21,000 --> 00:53:24,030
touch, and the question
mentioned touch explicitly,

1146
00:53:24,030 --> 00:53:28,600
which I just wanted to open it
to another dimension, which is

1147
00:53:28,600 --> 00:53:33,840
just a regular nav-down,
nav-right, nav-left, nav-up

1148
00:53:33,840 --> 00:53:37,800
events, which are the ones that
you'll receive when the

1149
00:53:37,800 --> 00:53:41,210
user is using a TV remote,
for instance, on a TV.

1150
00:53:41,210 --> 00:53:45,080
And it makes scrolling,
actually, a bit of a pain

1151
00:53:45,080 --> 00:53:48,460
because you have to handle it
yourself in the web app with

1152
00:53:48,460 --> 00:53:49,590
the nav-down.

1153
00:53:49,590 --> 00:53:53,540
And you have to, well, scroll
the viewport, obviously, and

1154
00:53:53,540 --> 00:53:57,040
then also handle links
in the good old days.

1155
00:53:57,040 --> 00:54:01,010
But the TV is kind of huge
screen, as opposed to the

1156
00:54:01,010 --> 00:54:04,950
mobile of 2000, where you had
the keypad, but you had the

1157
00:54:04,950 --> 00:54:07,570
small screen, so it was kind
of easy to make the

1158
00:54:07,570 --> 00:54:08,340
navigation.

1159
00:54:08,340 --> 00:54:10,990
So anyway, I just wanted
to raise the point.

1160
00:54:10,990 --> 00:54:15,460
Do not forget that there's more
than touch and mouse.

1161
00:54:15,460 --> 00:54:18,960
PETE LEPAGE: I think that's a
great point, and I think the

1162
00:54:18,960 --> 00:54:21,440
performance tip there of really
making sure that you're

1163
00:54:21,440 --> 00:54:25,030
being aware of where you're
putting your touch events,

1164
00:54:25,030 --> 00:54:28,010
listeners, and all that stuff
is a really great

1165
00:54:28,010 --> 00:54:29,560
point to end on.

1166
00:54:29,560 --> 00:54:32,310
I want to thank the panelists
for joining us up on stage.

1167
00:54:32,310 --> 00:54:35,470
I hope you guys learned
something, and it was quite

1168
00:54:35,470 --> 00:54:37,010
interesting for you.

1169
00:54:37,010 --> 00:54:38,490
And go build cool.

1170
00:54:38,490 --> 00:54:44,043

